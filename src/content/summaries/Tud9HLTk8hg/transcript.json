{
  "videoId": "Tud9HLTk8hg",
  "language": "en",
  "source": "caption-extractor",
  "segments": [
    {
      "start": 0.04,
      "duration": 6.28,
      "text": "I may have brought up the topic of AI agents once or twice before."
    },
    {
      "start": 6.96,
      "duration": 6.8,
      "text": "AI agents are autonomous systems. They perceive their environment. They"
    },
    {
      "start": 13.76,
      "duration": 6.6,
      "text": "make decisions based on those decisions. They can take actions. And this is all in"
    },
    {
      "start": 20.36,
      "duration": 6.56,
      "text": "service of achieving a goal. But how do different agents talk to each"
    },
    {
      "start": 26.92,
      "duration": 6.48,
      "text": "other to solve complex problems that a given agent can't solve by itself? Like, well, like"
    },
    {
      "start": 33.4,
      "duration": 6.119,
      "text": "travel planning, you might need to integrate a bunch of agents together, like a"
    },
    {
      "start": 39.68,
      "duration": 5.679,
      "text": "travel agent, and maybe that needs to integrate with a"
    },
    {
      "start": 45.759,
      "duration": 6.88,
      "text": "flight agent and a hotel agent and an excursion agent"
    },
    {
      "start": 52.64,
      "duration": 5.6,
      "text": "and so forth. Well, you could just build all of these agents yourself and then integrate them"
    },
    {
      "start": 58.24,
      "duration": 5.789,
      "text": "with some custom code. But what if you want to use somebody else's hotel agent without knowing how"
    },
    {
      "start": 64.029,
      "duration": 6.68,
      "text": "that agent communicates and how that agent works? It's not an easy task unless. Well, unless there"
    },
    {
      "start": 70.709,
      "duration": 5.76,
      "text": "was a standard way for AI agents to work with each other. Something that allows"
    },
    {
      "start": 76.47,
      "duration": 6.839,
      "text": "collaboration between agents, something that can handle authentication requirements, and something"
    },
    {
      "start": 83.309,
      "duration": 6.921,
      "text": "that defines a common communication method as well. That is what the"
    },
    {
      "start": 90.269,
      "duration": 6.24,
      "text": "A to A protocol, also known as the agent to"
    },
    {
      "start": 96.589,
      "duration": 6.84,
      "text": "agent protocol, was designed to do. It was initially introduced by Google in April"
    },
    {
      "start": 103.43,
      "duration": 6.4,
      "text": "2025, and a to A is now open source housed by the Linux Foundation. So"
    },
    {
      "start": 110.23,
      "duration": 6.76,
      "text": "how does it work? Well, let's start by talking about the core actors in A to A interactions. So"
    },
    {
      "start": 117.07,
      "duration": 6.79,
      "text": "we have got here a user. Now that could be a human operator, or it could be an automated service."
    },
    {
      "start": 123.86,
      "duration": 6.359,
      "text": "And it's the user that initiates a request, or it sets a goal which is going to need the help of"
    },
    {
      "start": 130.22,
      "duration": 6.359,
      "text": "one or more AI agents. So that request is received by"
    },
    {
      "start": 136.86,
      "duration": 6.8,
      "text": "the client agent, and that acts on behalf of the"
    },
    {
      "start": 143.66,
      "duration": 6.599,
      "text": "user and initiates requests to other agents. Those other agents, those"
    },
    {
      "start": 150.259,
      "duration": 6.84,
      "text": "are called remote agents. I'm just going to draw one remote"
    },
    {
      "start": 157.139,
      "duration": 6.72,
      "text": "agent here, but there could be a bunch of these in a mesh. But essentially these are"
    },
    {
      "start": 163.86,
      "duration": 6.96,
      "text": "all AI agents. And in some scenarios, a given AI agent might be considered the client agent"
    },
    {
      "start": 170.82,
      "duration": 5.28,
      "text": "making the cause. And in other cases, it might be considered the remote agent that's receiving them."
    },
    {
      "start": 176.1,
      "duration": 6.509,
      "text": "Now, the connection between the client agent and the remote"
    },
    {
      "start": 182.609,
      "duration": 7,
      "text": "agent uses the A to A protocol. Oh, and you might also"
    },
    {
      "start": 189.649,
      "duration": 7,
      "text": "see the client agent referred to as the A to A client, and the"
    },
    {
      "start": 196.649,
      "duration": 6.44,
      "text": "remote agent referred to as the A to A server, if you see that."
    },
    {
      "start": 203.13,
      "duration": 6.679,
      "text": "Well, it just means the same thing. So let's get into how this all works by looking at"
    },
    {
      "start": 209.809,
      "duration": 6.92,
      "text": "three stages. And we're going to start with number one which is discovery. So"
    },
    {
      "start": 216.729,
      "duration": 6.88,
      "text": "how does the client agent find the remote agent and figure out what that agent"
    },
    {
      "start": 223.61,
      "duration": 6.318,
      "text": "can actually do. Well it turns out that this remote agent actually publishes"
    },
    {
      "start": 229.929,
      "duration": 6.631,
      "text": "something called an agent card. And that contains"
    },
    {
      "start": 236.6,
      "duration": 6.879,
      "text": "basic information about the agent. So its identity, its capabilities, its skills. And it also"
    },
    {
      "start": 243.479,
      "duration": 6.201,
      "text": "includes a service endpoint URL that enables the a two way communication and some authentication"
    },
    {
      "start": 249.68,
      "duration": 6.839,
      "text": "requirements. And all of this takes the form of a JSON metadata document, which"
    },
    {
      "start": 256.519,
      "duration": 6.681,
      "text": "is served on the agent's domain. Okay, so let's focus in on the agent interactions here. So the"
    },
    {
      "start": 263.239,
      "duration": 6.44,
      "text": "client agent now knows how to find the remote agent. So now it is time for"
    },
    {
      "start": 269.76,
      "duration": 6.799,
      "text": "stage two. That is authentication. Now that happens through security"
    },
    {
      "start": 276.56,
      "duration": 6.999,
      "text": "scheme indicated in the agent card. So this is all based on"
    },
    {
      "start": 283.76,
      "duration": 6.68,
      "text": "authentication based on security scheme. Now when the client agent has been successfully or"
    },
    {
      "start": 290.44,
      "duration": 6.66,
      "text": "authenticated then the remote agent is responsible for authorization and"
    },
    {
      "start": 297.1,
      "duration": 6.759,
      "text": "granting access control permissions. Now, with that all out of the way, we can move on to"
    },
    {
      "start": 303.9,
      "duration": 6.839,
      "text": "stage three, which is communication. So in this case, the client agent is now ready to"
    },
    {
      "start": 310.78,
      "duration": 6.92,
      "text": "send a task to the remote agent. An agent to agent communication, A"
    },
    {
      "start": 317.739,
      "duration": 5.84,
      "text": "to A that uses the JSON RPC "
    },
    {
      "start": 323.98,
      "duration": 6.359,
      "text": "2.0 as the format for data exchange. And that is sent over"
    },
    {
      "start": 330.38,
      "duration": 6.559,
      "text": "https. Now, the remote agent's job now is to"
    },
    {
      "start": 336.98,
      "duration": 6.84,
      "text": "actually do the work. So it starts to process the task. And if"
    },
    {
      "start": 343.82,
      "duration": 6.319,
      "text": "it requires more information, it can notify the client agent to say, hey, I need some more"
    },
    {
      "start": 350.14,
      "duration": 6.469,
      "text": "information. So we might request more information here, which the client agent"
    },
    {
      "start": 356.609,
      "duration": 6.8,
      "text": "then provides. It then sends back to us. And then once this remote agent has"
    },
    {
      "start": 363.45,
      "duration": 6.318,
      "text": "actually completed its task, it can send a message to the"
    },
    {
      "start": 369.769,
      "duration": 6.8,
      "text": "client along with any generated artifacts and an artifact"
    },
    {
      "start": 376.57,
      "duration": 5.719,
      "text": "here is a tangible output that's generated by an agent during a task. So it could be a document or"
    },
    {
      "start": 382.289,
      "duration": 6.12,
      "text": "an image or structured data. Now this communication that I've described so far is"
    },
    {
      "start": 388.41,
      "duration": 6.719,
      "text": "request response. But some tasks might take the remote agent a little while to complete,"
    },
    {
      "start": 395.13,
      "duration": 6.04,
      "text": "like when there's human interaction involved, or perhaps where there are external events. So for"
    },
    {
      "start": 401.17,
      "duration": 6.36,
      "text": "long running tasks like those, if the agent card says that the remote agent supports streaming,"
    },
    {
      "start": 407.569,
      "duration": 6.71,
      "text": "then we can use streaming with SSE. That's server send events, that"
    },
    {
      "start": 414.279,
      "duration": 6.68,
      "text": "sends status updates about a given task from the remote agent to the client over an"
    },
    {
      "start": 420.96,
      "duration": 6.92,
      "text": "open HTTP connection. So the agent agent protocol provides some pretty useful benefits when it"
    },
    {
      "start": 427.88,
      "duration": 6.918,
      "text": "comes to discovery and authentication and a standardized communication, but also in the plus"
    },
    {
      "start": 434.799,
      "duration": 6.68,
      "text": "column, I think we really need to also include privacy. The protocol treats"
    },
    {
      "start": 441.6,
      "duration": 5.479,
      "text": "agentic AI as opaque agents, meaning the autonomous agents can collaborate without"
    },
    {
      "start": 447.119,
      "duration": 4.521,
      "text": "actually having to reveal their inner workings, such as their internal memory or proprietary"
    },
    {
      "start": 451.64,
      "duration": 5.879,
      "text": "logic, or any particular tool implementations that they use. It's pretty useful for preserving data"
    },
    {
      "start": 457.519,
      "duration": 6.88,
      "text": "privacy and IP, and because A to A builds on established standards, these"
    },
    {
      "start": 464.399,
      "duration": 6.2,
      "text": "are things that people are already using. And by that I'm talking about standards like"
    },
    {
      "start": 470.949,
      "duration": 6.96,
      "text": "HTTP and JSON, RPC and then SSD"
    },
    {
      "start": 478.07,
      "duration": 6.959,
      "text": "as well. Because of that, it makes it easier for enterprises to adopt the protocol. But look, A"
    },
    {
      "start": 485.07,
      "duration": 6.64,
      "text": "to A is in its early stages. This is all pretty new stuff and things will"
    },
    {
      "start": 491.71,
      "duration": 4.679,
      "text": "still improve. There are challenges still to overcome. There need to be improvements in"
    },
    {
      "start": 496.389,
      "duration": 6.16,
      "text": "security and governance and performance tuning, just to name a few. But at its core, A to A"
    },
    {
      "start": 502.549,
      "duration": 6.44,
      "text": "provides a way for AI agents to communicate over a trusted universal channel. It's a common"
    },
    {
      "start": 508.99,
      "duration": 5.719,
      "text": "language for agent ecosystems, and that's a good thing to have, because I have a feeling that this"
    },
    {
      "start": 514.71,
      "duration": 5.12,
      "text": "won't be the last time we talk about AI agents on this channel."
    }
  ],
  "fullText": "I may have brought up the topic of AI agents once or twice before. AI agents are autonomous systems. They perceive their environment. They make decisions based on those decisions. They can take actions. And this is all in service of achieving a goal. But how do different agents talk to each other to solve complex problems that a given agent can't solve by itself? Like, well, like travel planning, you might need to integrate a bunch of agents together, like a travel agent, and maybe that needs to integrate with a flight agent and a hotel agent and an excursion agent and so forth. Well, you could just build all of these agents yourself and then integrate them with some custom code. But what if you want to use somebody else's hotel agent without knowing how that agent communicates and how that agent works? It's not an easy task unless. Well, unless there was a standard way for AI agents to work with each other. Something that allows collaboration between agents, something that can handle authentication requirements, and something that defines a common communication method as well. That is what the A to A protocol, also known as the agent to agent protocol, was designed to do. It was initially introduced by Google in April 2025, and a to A is now open source housed by the Linux Foundation. So how does it work? Well, let's start by talking about the core actors in A to A interactions. So we have got here a user. Now that could be a human operator, or it could be an automated service. And it's the user that initiates a request, or it sets a goal which is going to need the help of one or more AI agents. So that request is received by the client agent, and that acts on behalf of the user and initiates requests to other agents. Those other agents, those are called remote agents. I'm just going to draw one remote agent here, but there could be a bunch of these in a mesh. But essentially these are all AI agents. And in some scenarios, a given AI agent might be considered the client agent making the cause. And in other cases, it might be considered the remote agent that's receiving them. Now, the connection between the client agent and the remote agent uses the A to A protocol. Oh, and you might also see the client agent referred to as the A to A client, and the remote agent referred to as the A to A server, if you see that. Well, it just means the same thing. So let's get into how this all works by looking at three stages. And we're going to start with number one which is discovery. So how does the client agent find the remote agent and figure out what that agent can actually do. Well it turns out that this remote agent actually publishes something called an agent card. And that contains basic information about the agent. So its identity, its capabilities, its skills. And it also includes a service endpoint URL that enables the a two way communication and some authentication requirements. And all of this takes the form of a JSON metadata document, which is served on the agent's domain. Okay, so let's focus in on the agent interactions here. So the client agent now knows how to find the remote agent. So now it is time for stage two. That is authentication. Now that happens through security scheme indicated in the agent card. So this is all based on authentication based on security scheme. Now when the client agent has been successfully or authenticated then the remote agent is responsible for authorization and granting access control permissions. Now, with that all out of the way, we can move on to stage three, which is communication. So in this case, the client agent is now ready to send a task to the remote agent. An agent to agent communication, A to A that uses the JSON RPC  2.0 as the format for data exchange. And that is sent over https. Now, the remote agent's job now is to actually do the work. So it starts to process the task. And if it requires more information, it can notify the client agent to say, hey, I need some more information. So we might request more information here, which the client agent then provides. It then sends back to us. And then once this remote agent has actually completed its task, it can send a message to the client along with any generated artifacts and an artifact here is a tangible output that's generated by an agent during a task. So it could be a document or an image or structured data. Now this communication that I've described so far is request response. But some tasks might take the remote agent a little while to complete, like when there's human interaction involved, or perhaps where there are external events. So for long running tasks like those, if the agent card says that the remote agent supports streaming, then we can use streaming with SSE. That's server send events, that sends status updates about a given task from the remote agent to the client over an open HTTP connection. So the agent agent protocol provides some pretty useful benefits when it comes to discovery and authentication and a standardized communication, but also in the plus column, I think we really need to also include privacy. The protocol treats agentic AI as opaque agents, meaning the autonomous agents can collaborate without actually having to reveal their inner workings, such as their internal memory or proprietary logic, or any particular tool implementations that they use. It's pretty useful for preserving data privacy and IP, and because A to A builds on established standards, these are things that people are already using. And by that I'm talking about standards like HTTP and JSON, RPC and then SSD as well. Because of that, it makes it easier for enterprises to adopt the protocol. But look, A to A is in its early stages. This is all pretty new stuff and things will still improve. There are challenges still to overcome. There need to be improvements in security and governance and performance tuning, just to name a few. But at its core, A to A provides a way for AI agents to communicate over a trusted universal channel. It's a common language for agent ecosystems, and that's a good thing to have, because I have a feeling that this won't be the last time we talk about AI agents on this channel.",
  "fetchedAt": "2026-01-18T18:33:07.255Z"
}