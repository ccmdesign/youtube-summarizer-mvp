<template>
  <div class="docs-index | stack" data-space="xl">
    <!-- Components (generated by vue-docs) -->
    <ccm-section>
      <div v-if="componentsPending" class="stack" data-space="xs">
        <h3>Components</h3>
        <p>Loading component catalogâ€¦</p>
      </div>
      <ul v-else-if="hasComponents" class="stack" data-space="xs">
        <h3>Components ({{ componentsList.length }})</h3>
        <p>Auto-generated API docs parsed from design system components.</p>

        <li v-for="item in componentsList" :key="item.name" class="component-card | box" data-padding="s" data-border="none">
          <div class="doc-info | stack" data-space="3xs">
            <NuxtLink :to="`/docs/components/${item.slug}`" class="doc-title">{{ item.displayName || item.name }}</NuxtLink>
            <span v-if="item.description" class="doc-description">{{ item.description }}</span>
            <ccmButton
              v-if="item.slug"
              size="s"
              variant="secondary"
              :to="`/docs/demos/${item.slug}-demo`"
              label="View demos"
            >
              View demos
            </ccmButton>
          </div>
        </li>
      </ul>
      <div v-else-if="componentsError" class="stack" data-space="xs">
        <h3>Components</h3>
        <p>Failed to load component documentation ({{ componentsError.message || 'unknown error' }}).</p>
        <p>Try rerunning <code>npm run docs:components:generate</code> or check server logs.</p>
      </div>
      <div v-else class="stack" data-space="xs">
        <h3>Components</h3>
        <p>Component API docs are generated from design system source files. Run <code>npm run docs:components:generate</code> before a build to refresh the catalog.</p>
      </div>
    </ccm-section>

    <!-- Guidelines -->
    <ccm-section v-if="docsByCategory.guidelines.length > 0">
      <ul class="stack" data-space="xs">
        <h3>Guidelines ({{ docsByCategory.guidelines.length }})</h3>
        <p>Design system guidelines and component standards.</p>

        <li v-for="doc in docsByCategory.guidelines" :key="doc.path" class="component-card | box" data-padding="s" data-border="none">
          <div class="doc-info | stack" data-space="3xs">
            <NuxtLink :to="doc.path" class="doc-title">{{ doc.title || doc.path.split('/').pop() }}</NuxtLink>
            <span v-if="doc.description" class="doc-description">{{ doc.description }}</span>
          </div>
        </li>
      </ul>
    </ccm-section>

    <!-- Tokens -->
    <ccm-section v-if="docsByCategory.tokens.length > 0">
      <ul class="stack" data-space="xs">
        <h3>Design Tokens ({{ docsByCategory.tokens.length }})</h3>
        <p>CSS tokens, color system, and design token documentation.</p>

        <li v-for="doc in docsByCategory.tokens" :key="doc.path" class="component-card | box" data-padding="s" data-border="none">
          <div class="doc-info | stack" data-space="3xs">
            <NuxtLink :to="doc.path" class="doc-title">{{ doc.title || doc.path.split('/').pop() }}</NuxtLink>
            <span v-if="doc.description" class="doc-description">{{ doc.description }}</span>
          </div>
        </li>
      </ul>
    </ccm-section>

    <!-- Utilities -->
    <ccm-section v-if="docsByCategory.utilities.length > 0">
      <ul class="stack" data-space="xs">
        <h3>Utilities ({{ docsByCategory.utilities.length }})</h3>
        <p>Utility classes and layout patterns.</p>

        <li v-for="doc in docsByCategory.utilities" :key="doc.path" class="component-card | box" data-padding="s" data-border="none">
          <div class="doc-info | stack" data-space="3xs">
            <NuxtLink :to="doc.path" class="doc-title">{{ doc.title || doc.path.split('/').pop() }}</NuxtLink>
            <span v-if="doc.description" class="doc-description">{{ doc.description }}</span>
          </div>
        </li>
      </ul>
    </ccm-section>
  </div>
</template>

<script setup>
definePageMeta({
  hero: {
    brow: 'Documentation',
    title: 'Documentation',
    tagline: 'Authoritative component and utility docs',
    size: 'l',
    hideTopbar: false
  }
})

const toComponentSlug = (name) => {
  if (!name) return ''
  return name
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase()
}

// Fetch components index with static-first + API fallback
const loadStaticComponentIndex = async () => {
  try {
    const module = await import('~/public/component-docs/index.json')
    const items = module.default || module
    if (Array.isArray(items)) {
      return items.filter((i) => i && i.name)
    }
  } catch (error) {
    if (import.meta.dev) {
      console.warn('[docs] Static component docs index unavailable', error)
    }
  }
  return null
}

const { data: componentsIndex, pending: componentsPending, error: componentsError } = await useAsyncData('docs-components-index', async () => {
  const staticItems = await loadStaticComponentIndex()
  if (staticItems) {
    return staticItems
  }

  // Fallback to live API (useful during dev or if generator hasn't run)
  try {
    const items = await $fetch('/api/component-docs')
    if (Array.isArray(items)) {
      return items
    }
  } catch (error) {
    if (import.meta.dev) {
      console.warn('[docs] Failed to fetch component docs from API', error)
    }
  }

  return []
})

const componentsList = computed(() => {
  const list = componentsIndex.value || []
  return list.map((item) => ({
    ...item,
    slug: toComponentSlug(item.name)
  }))
})
const hasComponents = computed(() => componentsList.value.length > 0 && !componentsError.value)

// Query all documentation
const { data: docs } = await useAsyncData('docs-index', () => {
  return queryCollection('docs').all()
})

// Extract category from path (e.g., /docs/guidelines/component-standards -> guidelines)
const getCategoryFromPath = (path) => {
  const segments = path?.split('/').filter(Boolean) || []
  const categoryIndex = segments.indexOf('docs')
  if (categoryIndex !== -1 && segments[categoryIndex + 1]) {
    return segments[categoryIndex + 1].toLowerCase()
  }
  return 'other'
}

// Organize docs by category
const docsByCategory = computed(() => {
  const all = docs.value || []
  
  const categories = {
    guidelines: [],
    tokens: [],
    utilities: [],
    other: []
  }
  
  all.forEach(doc => {
    const category = getCategoryFromPath(doc.path)
    if (categories[category]) {
      categories[category].push(doc)
    } else {
      categories.other.push(doc)
    }
  })
  
  // Sort each category by title
  Object.keys(categories).forEach(category => {
    categories[category].sort((a, b) => {
      const titleA = a.title || a.path?.split('/').pop() || ''
      const titleB = b.title || b.path?.split('/').pop() || ''
      return titleA.localeCompare(titleB)
    })
  })
  
  return categories
})


</script>

<style scoped>
li {
  display: flex;
}

.doc-info {
  flex: 1;
}
</style>
